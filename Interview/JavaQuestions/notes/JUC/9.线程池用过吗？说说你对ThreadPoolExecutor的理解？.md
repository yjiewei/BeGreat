## 9.线程池用过吗？说说你对ThreadPoolExecutor的理解？

```java
/**
 * 多线程中三种常用的获得多线程的方法
 *  1.继承thread类
 *  2.实现runnable接口
 *  3.实现callable接口
 * callable是会带返回值的线程接口，还会抛出异常，实现方法为call
 */
class MyThread implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName()+"========");
        return 1024;
    }
}
public class CallableDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 这里很有意思的点就是：thread类构造方法没有直接传callable的
        // 他用了适配器模式，用runnable的子接口RunnableFuture<V>的一个实现类FutureTask。
        // 实现适配
        // FutureTask(Callable<V> callable)
        // 使用场景：多线程后台计算啊
        // futureTask.get()会要求一定要获得执行结果，如果计算不完成会导致堵塞。直到你拿到结果。主要保证主线程也无法退出。
        // 一般最后才执行这个操作
        FutureTask<Integer> futureTask = new FutureTask<>(new MyThread());
        FutureTask<Integer> futureTask1 = new FutureTask<>(new MyThread());

        Thread thread = new Thread(futureTask, "AA");
        new Thread(futureTask, "BB").start(); // 同一个futuretask只会执行一次，一个任务为什么要做两次呢？java会复用
       // new Thread(futureTask1,"BB").start(); // 这个就是两个任务两个线程必定跑两次
        thread.start();
        System.out.println(Thread.currentThread().getName());
//        while (!futureTask.isDone()){
//            System.out.println(Thread.currentThread().getName() + "这里就有点像自旋锁，一直让主线程等在这");
//        }
        Integer integer = futureTask.get(); // get方法获取返回值。
        System.out.println("我的返回值是：" + integer);
    }
}
```

### 9.1 为什么用线程池呢？有什么优势

>  减少上下文切换，降低性能开销。

<img src="9.线程池用过吗？说说你对ThreadPoolExecutor的理解？.assets/image-20201210204652931.png" alt="image-20201210204652931" style="zoom:150%;" />