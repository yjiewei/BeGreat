## [查找算法](https://mp.weixin.qq.com/s/NhQYOhIqusj4YOWxdQFGPw)

1、顺序查找

顺序查找适合用于存储结构为顺序存储或者链式存储的线性表。

顺序扫描线性表，属于无序查找算法。时间复杂度为O(n)

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7YdoyYQaFIptDR80k3oejZbgS0MSm10wYxNanITdXphgtsDcz1mTibROVFibX7iaSAW7a6nkV7Omibkiaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  2、二分查找

大前提：元素必须是有序的，如果无序需要排个序才行。

二分查找也叫折半查找，属于有序查找算法，基本思想是每次查询将目标元素与中间节点进行比较，比中间节点大就往右边找（递归），比中间节点小就往左边找，直到 left>right。

时间复杂度：可以把它看做是一棵二叉树，最坏就是树的深度O(logN)。

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7YdoyYQaFIptDR80k3oejZbERbthnhaAsdtyPrOHx4A8vLqwCuK2lczMEAS3KBggEJzjYsIpAP4zg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  3、插值查找

插值查找是基于二分查找算法，对查找点mid进行改进，是索引和值的一种平衡，前提依旧是有序。

mid = left + (right-left)*(value - a[left])/(a[right] a[left])

优点：对于数据量大、分布均匀的查找表来说，效率高于二分查找；

缺点：对于分布不均匀的数组来说，未必是一种好的选择。

bug：有可能出现越界、栈溢出的情况。

时间复杂度：平均情况 O(loglogN)，最坏 O(logN)??

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7YdoyYQaFIptDR80k3oejZbQXPuGeBFsxhOybp82KpJVib7RhbhuOQMSdFsgKibgf3StFK20vxZAyTQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  4、斐波那契查找

时间复杂度为 O(log n)

基本思想：斐波那契查找就是在二分查找的基础上根据斐波那契数列分割的，在数列中找一个等于略大于查找表长度的数f[k]，将我们要找的表长度扩展为f[k]-1，如果数组长度不够，要扩展，扩展的元素用数组最后一个元素填充，mid = low + f[k-1] -1，以mid为分割点，将数组划分为左右两边。

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZhQOfs9Wc3ytkCKERgWIMCvGD8IpgRWVQgopRqOsxwyZpmMygzYDWcqE4YXfWUdxibuCDRbuHvqMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

为什么这里数组长度要f[k]-1呢？

答：假如数组长度为f[k],不考虑mid的情况下，左边为f[k - 1],右边为f[k -2],考虑mid的情况下要不左边是f[k - 1] - 1或者右边是f[k - 2] - 1，逻辑不好写；如果待查找长度为f[k] - 1，mid = low + (f[k - 1] - 1)则不存在这样的问题

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZhQOfs9Wc3ytkCKERgWIMCema9o71OOjCF0pn8QDe2ndk5rpKXDIvxyicxmrxJj7hl3FhrJhSfXLw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)