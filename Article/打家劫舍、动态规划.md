## [打家劫舍、动态规划](https://mp.weixin.qq.com/s/othn1DUH7oeAT8Q-ktCKTQ)

什么是动态规划？

它是运筹学的一个分支，是求解决策过程最优化的过程。

如何判断一个问题是不是动态规划问题？

它的一般形式是求最值，核心问题是就是穷举在里面找最值，穷举的话效率太低，存在重叠子问题，所以需要找到最优子结构，找到状态转移方程才能解决。



状态转移方程框架：

 **明确[状态] -->定义dp数组/函数的含义-->明确[选择]-->明确base case**

f**k 这么难

####  

#### 198. 打家劫舍 

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。



给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。



示例 1：

输入：[1,2,3,1]

输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。

​     偷窃到的最高金额 = 1 + 3 = 4 。



示例 2：

输入：[2,7,9,3,1]

输出：12

解释：偷窃1房屋 (金额=2), 偷窃 3 号房屋 (金额=9)，接着偷窃 5 号房屋 (金额 = 1)。

   偷窃到的最高金额 = 2 + 9 + 1 = 12 。



![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZTaJvznib3ZPWQBpTuok4sk6ueAZJ2WQh5HppYZolAKxtLrQZA3xPFesaB8NIXjFOFmNlmpuTFS6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

以上逻辑明确了状态和选择：你面前的房子的索引就是状态，抢和不抢就是选择。

因为当前状态只与前两个状态相关，只需要两个变量就可以了，不需要一个数组。

时间复杂度为O(n) 空间复杂度为O(1)

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZTaJvznib3ZPWQBpTuok4skXlbL7QxMy6jgkzicvw1UIO3eVMwYXo3UrxicHITicTvaeY39WUtWLdLbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

####   213. 打家劫舍 II

在198的基础上，数组首尾相连围成了一个圈。

例如：

输入: [2,3,2]

输出: 3

解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）,因为他们是相邻的。



如何解决环形数组呢？

比如单调栈。那这个问题呢？



将环形问题转化为前面的单排问题：

1.在不偷窃第一个房子的情况下（即 nums[1:]），最大金额是 p1；

2.在不偷窃最后一个房子的情况下（即 nums[:n-1]），最大金额是 p2 。

3.第一个房子和最后一个都没有被偷，由于前两种的选择包含了第三种，这种可以不比较

返回两者之间的最大值即可。

时间复杂度为O(n) 空间复杂度为O(1)

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZTaJvznib3ZPWQBpTuok4skQTjSHsXMHsT3vQnITE4evwjp1TO19mib5w0ppmribeXDIUibjMj3ZGVQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZTaJvznib3ZPWQBpTuok4skic79RwKNqq00xWPpxAHhTE8vviaJ2WmtRRKIK1QtbL2sw4SnbnEw0p0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZTaJvznib3ZPWQBpTuok4skQb6hqF5OtCThYPs6iabycE5sCTQxhuFCMqS61oXxxrX41m3RIibicGGPQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



####   337. 打家劫舍 III

小偷发现这次要偷的房子不是单排，不是环形，而是一颗二叉树，房子在二叉树的节点上，相连的两个房子不能同时被抢！niubi这小偷比我聪明多了

例子：

输入: [3,2,3,null,3,null,1]

```

      3    
     / \   
    2   3    
     \   \      
      3   1
```

输出: 7 

解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.



输入: [3,4,5,1,3,null,1]

```
     3
    / \
   4   5
  / \   \ 
 1   3   1
```

输出: 9

解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.

整体的思路依旧没变，遍历数组换成了遍历二叉树，依旧抢不抢的问题。

1.偷当前节点，则不能偷左右节点 val1

2.不偷当前节点，偷左右节点 val2

比较获得最大值，递归嘛

时间复杂度为 O(n) 空间复杂度就递归需要的堆栈空间

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZTaJvznib3ZPWQBpTuok4sk8gvttXhZyic0fvoV88CZ4NUFE5csOODoRPTxjdclRiadGpF4eSjCBfCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZTaJvznib3ZPWQBpTuok4skuZ75FibhSQpHXMUicyYA2Dl3leCnZibc17IiaTvAoomfKIiaxtU5MTe2FYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_png/0SQf4xMzia7ZTaJvznib3ZPWQBpTuok4skdHkRbFQvvSrtsRYxez9qIedKqFg7LNHWPWR2G9Tib9xg1ZJhQGa0icHg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

并没有真正理解！不要忘记回来复习！