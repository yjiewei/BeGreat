#### [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

```java
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？（位运算）
    
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
    
输入：nums = [-1,0]
输出：[-1,0]
    
输入：nums = [0,1]
输出：[1,0]
```



**答题思路：** 

```
1.最简单的方式就是统计出现次数，选出只出现一次的值
2.位运算
  这里的位运算出现多次，第一次获得了两个答案值的异或值，这个值给后面获取答案值提供分组，将a,b分开去与相同分组的值进行异或，
```



**答题代码：** 

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        // 两个只出现一次，其余均为两次
        // 1.用哈希表 时间空间都是O(N)
        Map<Integer, Integer> map = new HashMap<>();
        int[] result = new int[2];
        for(int num : nums) {
            if(map.containsKey(num)) {
                map.remove(num);
            }else {
                map.put(num, num);
            }
        }
        int j = 0;
        for(Integer key : map.keySet()) {
            result[j++] = map.get(key); 
        }
        return result;
    }
}
```

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        // 两个只出现一次，其余均为两次
        // 2.用位运算
        // 2.1 获取异或值
        if(nums.length == 2) return nums;
        int a = 0;
        int b = 0;
        int xor = 0;
        for(int num : nums) {
            xor ^= num;
        }

        // 从右往左，异或值中为1的部分，分为两组
        int div = 1;
        while((xor & div) == 0) {
            div = div << 1; // 他俩相与不为0
            // 这一步很重要，相当于找到异或值不为0的区分位，用这一位来区分其他的数
        }
        // 遍历num ， 异或出ab
        for(int num:nums){
            // 区分其他数和他的与值，相同的就放在同一组了，但是ab却能够分开
            if((num & div) == 0) {
                a ^= num;
            }else {
                b ^= num;
            }
        }
        return new int[]{a, b};
    }
}
```

